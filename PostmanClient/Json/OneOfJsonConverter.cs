// This file was generated by liblab | https://liblab.com/

using System.Text.Json;
using System.Text.Json.Serialization;
using PostmanClient.Extensions;
using PostmanClient.OneOf;

namespace PostmanClient.Json;

internal class OneOfJsonConverter<TOneOf> : JsonConverter<TOneOf>
    where TOneOf : IOneOf, new()
{
    private record OneOfType(int Index, Type Type);

    private record OneOfCandidate(OneOfType OneOfType, object Obj);

    private record OneOfObjectCandidate(
        OneOfType OneOfType,
        object Obj,
        int RequiredPropertiesCount,
        int OptionalPropertiesCount
    ) : OneOfCandidate(OneOfType, Obj);

    public override void Write(Utf8JsonWriter writer, TOneOf value, JsonSerializerOptions options)
    {
        JsonSerializer.Serialize(writer, value.Value, options);
    }

    public override TOneOf? Read(
        ref Utf8JsonReader reader,
        Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        var oneOfTypes = typeof(TOneOf)
            .GetGenericArguments()
            .Select((type, i) => new OneOfType(i, type))
            .ToArray();

        var readerCopy = reader;
        reader.Skip();

        if (readerCopy.TokenType == JsonTokenType.PropertyName)
        {
            readerCopy.Read();
        }

        var bestCandidate = GetBestMatchingCandidate(ref readerCopy, oneOfTypes, options);
        return IOneOf.CreateInstance<TOneOf>(bestCandidate.OneOfType.Index, bestCandidate.Obj);
    }

    private static OneOfCandidate GetBestMatchingCandidate(
        ref Utf8JsonReader reader,
        OneOfType[] oneOfTypes,
        JsonSerializerOptions options
    )
    {
        return reader.TokenType switch
        {
            JsonTokenType.StartObject => GetBestMatchingObject(ref reader, oneOfTypes, options),
            JsonTokenType.StartArray => GetBestMatchingCollection(ref reader, oneOfTypes, options),
            _ => GetBestMatchingPrimitive(ref reader, oneOfTypes, options),
        };
    }

    private static OneOfCandidate GetBestMatchingCollection(
        ref Utf8JsonReader reader,
        OneOfType[] oneOfTypes,
        JsonSerializerOptions options
    )
    {
        var readerCopy = reader;
        readerCopy.Read();

        var collectionTypes = oneOfTypes
            .Where((oneOfType) => oneOfType.Type.IsCollectionType())
            .Select(oneOfType =>
                oneOfType with
                {
                    Type = oneOfType.Type.GetGenericArguments().Single()
                }
            )
            .ToArray();

        if (collectionTypes.Length == 0)
        {
            throw new JsonException("Could not find collection type in OneOf.");
        }

        if (readerCopy.TokenType == JsonTokenType.EndArray)
        {
            var listType = typeof(List<>).MakeGenericType(collectionTypes[0].Type);
            var instance =
                Activator.CreateInstance(listType)
                ?? throw new InvalidOperationException("Failed to create List instance");
            return new OneOfCandidate(collectionTypes[0], instance);
        }

        var bestInnerTypeCandidate = GetBestMatchingCandidate(
            ref readerCopy,
            collectionTypes,
            options
        );

        var bestCollectionType = oneOfTypes.Single(oneOfType =>
            oneOfType.Index == bestInnerTypeCandidate.OneOfType.Index
        );

        var deserializedCollection = JsonSerializer.Deserialize(
            ref reader,
            bestCollectionType.Type,
            options
        );

        return new OneOfCandidate(bestCollectionType, deserializedCollection!);
    }

    private static OneOfCandidate GetBestMatchingPrimitive(
        ref Utf8JsonReader reader,
        OneOfType[] oneOfTypes,
        JsonSerializerOptions options
    )
    {
        OneOfType? bestPrimitive = null;
        switch (reader.TokenType)
        {
            case JsonTokenType.String:
            {
                bestPrimitive = oneOfTypes.FirstOrDefault(x => x.Type == typeof(string));
                break;
            }
            case JsonTokenType.False
            or JsonTokenType.True:
            {
                bestPrimitive = oneOfTypes.FirstOrDefault(x => x.Type == typeof(bool));
                break;
            }
            case JsonTokenType.Number:
            {
                if (reader.TryGetInt64(out _))
                {
                    var longType = oneOfTypes.FirstOrDefault(x => x.Type == typeof(long));
                    if (longType is not null)
                    {
                        bestPrimitive = longType;
                        break;
                    }
                }
                bestPrimitive = oneOfTypes.FirstOrDefault(x => x.Type == typeof(double));
                break;
            }
        }

        if (bestPrimitive is null)
        {
            throw new JsonException("Could not find matching primitive type for OneOf.");
        }

        var deserializedValue = JsonSerializer.Deserialize(ref reader, bestPrimitive.Type, options);

        return new OneOfCandidate(bestPrimitive, deserializedValue!);
    }

    private static OneOfObjectCandidate GetBestMatchingObject(
        ref Utf8JsonReader reader,
        OneOfType[] oneOfTypes,
        JsonSerializerOptions options
    )
    {
        var candidates = CreateObjectCandidates(reader, oneOfTypes, options);
        var maxRequiredProperties = candidates.Max(candidate => candidate.RequiredPropertiesCount);
        return candidates
            .Where(candidate => candidate.RequiredPropertiesCount == maxRequiredProperties)
            .MaxBy(candidate => candidate.OptionalPropertiesCount)!;
    }

    private static List<OneOfObjectCandidate> CreateObjectCandidates(
        Utf8JsonReader reader,
        OneOfType[] oneOfTypes,
        JsonSerializerOptions options
    )
    {
        List<OneOfObjectCandidate> candidates = new();

        foreach (var oneOfType in oneOfTypes)
        {
            if (oneOfType.Type.IsPrimitive)
                continue;

            var readerCopy = reader;
            var deserializedObject = JsonSerializer.Deserialize(
                ref readerCopy,
                oneOfType.Type,
                options
            );

            if (deserializedObject is null || !HasAllRequiredProperties(deserializedObject))
                continue;

            var (requiredCount, optionalCount) = CountProperties(deserializedObject);

            candidates.Add(
                new OneOfObjectCandidate(
                    oneOfType,
                    deserializedObject,
                    requiredCount,
                    optionalCount
                )
            );
        }

        if (candidates.Count == 0)
        {
            throw new JsonException("Could not find valid model match for OneOf.");
        }

        return candidates;
    }

    private static bool HasAllRequiredProperties(object obj)
    {
        var properties = obj.GetType().GetProperties();
        return properties.All(
            (property) =>
            {
                var isOptional = property.IsNullable();
                var hasValue = property.GetValue(obj) is not null;
                return isOptional || hasValue;
            }
        );
    }

    private static (int requiredCount, int optionalCount) CountProperties(object obj)
    {
        var requiredCount = 0;
        var optionalCount = 0;

        foreach (var property in obj.GetType().GetProperties())
        {
            if (property.GetValue(obj) == null)
                continue;
            if (property.IsNullable())
            {
                optionalCount++;
            }
            else
            {
                requiredCount++;
            }
        }

        return (requiredCount, optionalCount);
    }
}
