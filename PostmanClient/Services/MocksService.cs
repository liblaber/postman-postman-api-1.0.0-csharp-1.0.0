// This file was generated by liblab | https://liblab.com/

using System.Net.Http.Json;
using PostmanClient.Http;
using PostmanClient.Http.Serialization;
using PostmanClient.Models;

namespace PostmanClient.Services;

public class MocksService : BaseService
{
    internal MocksService(HttpClient httpClient)
        : base(httpClient) { }

    /// <summary>
    /// Gets all mock servers. By default, this endpoint returns only mock servers you created across all workspaces.
    ///
    /// **Note:**
    ///
    /// If you pass both the `teamId` and `workspace` query parameters, this endpoint only accepts the `workspace` query.
    /// </summary>
    /// <param name="teamId">Return only results that belong to the given team ID.</param>
    /// <param name="workspace">Return only results found in the given workspace.</param>
    public async Task<GetMocks> GetMocksAsync(
        string? teamId = null,
        string? workspace = null,
        CancellationToken cancellationToken = default
    )
    {
        var request = new RequestBuilder(HttpMethod.Get, "mocks")
            .SetOptionalQueryParameter("teamId", teamId)
            .SetOptionalQueryParameter("workspace", workspace)
            .Build();

        var response = await _httpClient
            .SendAsync(request, cancellationToken)
            .ConfigureAwait(false);
        response.EnsureSuccessStatusCode();

        return await response
                .Content.ReadFromJsonAsync<GetMocks>(_jsonSerializerOptions, cancellationToken)
                .ConfigureAwait(false) ?? throw new Exception("Failed to deserialize response.");
    }

    /// <summary>
    /// Creates a mock server in a collection.
    ///
    /// **Note:**
    ///
    /// - If you do not include the `workspaceId` query parameter, the system creates the mock server in your [Personal
    /// workspace](https://learning.postman.com/docs/collaborating-in-postman/using-workspaces/creating-workspaces/).
    /// - You cannot create mocks for collections added to an API definition.
    /// </summary>
    /// <param name="workspaceId">The workspace's ID.</param>
    public async Task<MockCreateUpdate> CreateMockAsync(
        CreateMock input,
        string? workspaceId = null,
        CancellationToken cancellationToken = default
    )
    {
        ArgumentNullException.ThrowIfNull(input, nameof(input));

        var request = new RequestBuilder(HttpMethod.Post, "mocks")
            .SetOptionalQueryParameter("workspaceId", workspaceId)
            .SetContentAsJson(input, _jsonSerializerOptions)
            .Build();

        var response = await _httpClient
            .SendAsync(request, cancellationToken)
            .ConfigureAwait(false);
        response.EnsureSuccessStatusCode();

        return await response
                .Content.ReadFromJsonAsync<MockCreateUpdate>(
                    _jsonSerializerOptions,
                    cancellationToken
                )
                .ConfigureAwait(false) ?? throw new Exception("Failed to deserialize response.");
    }

    /// <summary>Gets information about a mock server.</summary>
    /// <param name="mockId">The mock's ID.</param>
    public async Task<GetMock> GetMockAsync(
        string mockId,
        CancellationToken cancellationToken = default
    )
    {
        ArgumentNullException.ThrowIfNull(mockId, nameof(mockId));

        var request = new RequestBuilder(HttpMethod.Get, "mocks/{mockId}")
            .SetPathParameter("mockId", mockId)
            .Build();

        var response = await _httpClient
            .SendAsync(request, cancellationToken)
            .ConfigureAwait(false);
        response.EnsureSuccessStatusCode();

        return await response
                .Content.ReadFromJsonAsync<GetMock>(_jsonSerializerOptions, cancellationToken)
                .ConfigureAwait(false) ?? throw new Exception("Failed to deserialize response.");
    }

    /// <summary>Updates a mock server.</summary>
    /// <param name="mockId">The mock's ID.</param>
    public async Task<MockCreateUpdate> UpdateMockAsync(
        UpdateMock input,
        string mockId,
        CancellationToken cancellationToken = default
    )
    {
        ArgumentNullException.ThrowIfNull(input, nameof(input));
        ArgumentNullException.ThrowIfNull(mockId, nameof(mockId));

        var request = new RequestBuilder(HttpMethod.Put, "mocks/{mockId}")
            .SetPathParameter("mockId", mockId)
            .SetContentAsJson(input, _jsonSerializerOptions)
            .Build();

        var response = await _httpClient
            .SendAsync(request, cancellationToken)
            .ConfigureAwait(false);
        response.EnsureSuccessStatusCode();

        return await response
                .Content.ReadFromJsonAsync<MockCreateUpdate>(
                    _jsonSerializerOptions,
                    cancellationToken
                )
                .ConfigureAwait(false) ?? throw new Exception("Failed to deserialize response.");
    }

    /// <summary>Deletes a mock server.</summary>
    /// <param name="mockId">The mock's ID.</param>
    public async Task<DeleteMock> DeleteMockAsync(
        string mockId,
        CancellationToken cancellationToken = default
    )
    {
        ArgumentNullException.ThrowIfNull(mockId, nameof(mockId));

        var request = new RequestBuilder(HttpMethod.Delete, "mocks/{mockId}")
            .SetPathParameter("mockId", mockId)
            .Build();

        var response = await _httpClient
            .SendAsync(request, cancellationToken)
            .ConfigureAwait(false);
        response.EnsureSuccessStatusCode();

        return await response
                .Content.ReadFromJsonAsync<DeleteMock>(_jsonSerializerOptions, cancellationToken)
                .ConfigureAwait(false) ?? throw new Exception("Failed to deserialize response.");
    }

    /// <summary>
    /// Gets a mock server's call logs. You can get a maximum of 6.5MB of call logs or a total of 100 call logs, whichever limit is met first in one API call.
    ///
    /// Call logs contain exchanged request and response data made to mock servers. The logs provide visibility into how the mock servers are being used. You can log data to debug, test, analyze, and more, depending upon the use case.
    /// </summary>
    /// <param name="mockId">The mock's ID.</param>
    /// <param name="limit">The maximum number of rows to return in the response.</param>
    /// <param name="cursor">The pointer to the first record of the set of paginated results. To view the next response, use the `nextCursor` value for this parameter.</param>
    /// <param name="until">Return only results created until this given time, in [ISO 8601](https://datatracker.ietf.org/doc/html/rfc3339#section-5.6) format. This value cannot be earlier than the `since` value.</param>
    /// <param name="since">Return only results created since the given time, in [ISO 8601](https://datatracker.ietf.org/doc/html/rfc3339#section-5.6) format. This value cannot be later than the `until` value.</param>
    /// <param name="responseStatusCode">Return only call logs that match the given HTTP response status code.</param>
    /// <param name="responseType">Return only call logs that match the given response type. Matching is not case-sensitive.</param>
    /// <param name="requestMethod">Return only call logs that match the given HTTP method. Matching is not case-sensitive.</param>
    /// <param name="requestPath">Return only call logs that match the given request path. Matching is not case-sensitive.</param>
    /// <param name="sort">Sort the results by the given value. If you use this query parameter, you must also use the `direction` parameter.</param>
    /// <param name="direction">Sort in ascending (`asc`) or descending (`desc`) order. Matching is not case-sensitive. If you use this query parameter, you must also use the `sort` parameter.</param>
    /// <param name="include">Include call log records with header and body data. This query parameter accepts the `request.headers`, `request.body`, `response.headers`, and `response.body` values. For multiple include types, comma-separate each value.</param>
    public async Task<GetMockCallLogs> GetMockCallLogsAsync(
        string mockId,
        double? limit = null,
        string? cursor = null,
        string? until = null,
        string? since = null,
        double? responseStatusCode = null,
        string? responseType = null,
        string? requestMethod = null,
        string? requestPath = null,
        GetMockCallLogsSort? sort = null,
        AscDesc? direction = null,
        string? include = null,
        CancellationToken cancellationToken = default
    )
    {
        ArgumentNullException.ThrowIfNull(mockId, nameof(mockId));

        var request = new RequestBuilder(HttpMethod.Get, "mocks/{mockId}/call-logs")
            .SetPathParameter("mockId", mockId)
            .SetOptionalQueryParameter("limit", limit)
            .SetOptionalQueryParameter("cursor", cursor)
            .SetOptionalQueryParameter("until", until)
            .SetOptionalQueryParameter("since", since)
            .SetOptionalQueryParameter("responseStatusCode", responseStatusCode)
            .SetOptionalQueryParameter("responseType", responseType)
            .SetOptionalQueryParameter("requestMethod", requestMethod)
            .SetOptionalQueryParameter("requestPath", requestPath)
            .SetOptionalQueryParameter("sort", sort?.Value)
            .SetOptionalQueryParameter("direction", direction?.Value)
            .SetOptionalQueryParameter("include", include)
            .Build();

        var response = await _httpClient
            .SendAsync(request, cancellationToken)
            .ConfigureAwait(false);
        response.EnsureSuccessStatusCode();

        return await response
                .Content.ReadFromJsonAsync<GetMockCallLogs>(
                    _jsonSerializerOptions,
                    cancellationToken
                )
                .ConfigureAwait(false) ?? throw new Exception("Failed to deserialize response.");
    }

    /// <summary>Publishes a mock server. Publishing a mock server sets its **Access Control** configuration setting to public.</summary>
    /// <param name="mockId">The mock's ID.</param>
    public async Task<PublishMock> PublishMockAsync(
        string mockId,
        CancellationToken cancellationToken = default
    )
    {
        ArgumentNullException.ThrowIfNull(mockId, nameof(mockId));

        var request = new RequestBuilder(HttpMethod.Post, "mocks/{mockId}/publish")
            .SetPathParameter("mockId", mockId)
            .Build();

        var response = await _httpClient
            .SendAsync(request, cancellationToken)
            .ConfigureAwait(false);
        response.EnsureSuccessStatusCode();

        return await response
                .Content.ReadFromJsonAsync<PublishMock>(_jsonSerializerOptions, cancellationToken)
                .ConfigureAwait(false) ?? throw new Exception("Failed to deserialize response.");
    }

    /// <summary>Unpublishes a mock server. Unpublishing a mock server sets its **Access Control** configuration setting to private.</summary>
    /// <param name="mockId">The mock's ID.</param>
    public async Task<UnpublishMock> UnpublishMockAsync(
        string mockId,
        CancellationToken cancellationToken = default
    )
    {
        ArgumentNullException.ThrowIfNull(mockId, nameof(mockId));

        var request = new RequestBuilder(HttpMethod.Delete, "mocks/{mockId}/unpublish")
            .SetPathParameter("mockId", mockId)
            .Build();

        var response = await _httpClient
            .SendAsync(request, cancellationToken)
            .ConfigureAwait(false);
        response.EnsureSuccessStatusCode();

        return await response
                .Content.ReadFromJsonAsync<UnpublishMock>(_jsonSerializerOptions, cancellationToken)
                .ConfigureAwait(false) ?? throw new Exception("Failed to deserialize response.");
    }

    /// <summary>Gets all of a mock server's server responses.</summary>
    /// <param name="mockId">The mock's ID.</param>
    public async Task<List<GetMockServerResponses>> GetMockServerResponsesAsync(
        string mockId,
        CancellationToken cancellationToken = default
    )
    {
        ArgumentNullException.ThrowIfNull(mockId, nameof(mockId));

        var request = new RequestBuilder(HttpMethod.Get, "mocks/{mockId}/server-responses")
            .SetPathParameter("mockId", mockId)
            .Build();

        var response = await _httpClient
            .SendAsync(request, cancellationToken)
            .ConfigureAwait(false);
        response.EnsureSuccessStatusCode();

        return await response
                .Content.ReadFromJsonAsync<List<GetMockServerResponses>>(
                    _jsonSerializerOptions,
                    cancellationToken
                )
                .ConfigureAwait(false) ?? throw new Exception("Failed to deserialize response.");
    }

    /// <summary>
    /// Creates a server response. Server responses let you simulate 5xx server-level responses, such as 500 or 503.
    ///
    /// Server-level responses are agnostic to application-level logic. Server responses let you simulate this behavior on a mock server. You do not need to define each error for all exposed paths on the mock server.
    ///
    /// If you set a server response as active, then all the calls to the mock server return with that active server response.
    ///
    /// **Note:**
    ///
    /// You can create multiple server responses for a mock server, but only one mock server can be set as active.
    /// </summary>
    /// <param name="mockId">The mock's ID.</param>
    public async Task<object> CreateMockServerResponseAsync(
        CreateMockServerResponse input,
        string mockId,
        CancellationToken cancellationToken = default
    )
    {
        ArgumentNullException.ThrowIfNull(input, nameof(input));
        ArgumentNullException.ThrowIfNull(mockId, nameof(mockId));

        var request = new RequestBuilder(HttpMethod.Post, "mocks/{mockId}/server-responses")
            .SetPathParameter("mockId", mockId)
            .SetContentAsJson(input, _jsonSerializerOptions)
            .Build();

        var response = await _httpClient
            .SendAsync(request, cancellationToken)
            .ConfigureAwait(false);
        response.EnsureSuccessStatusCode();

        return await response
                .Content.ReadFromJsonAsync<object>(_jsonSerializerOptions, cancellationToken)
                .ConfigureAwait(false) ?? throw new Exception("Failed to deserialize response.");
    }

    /// <summary>Gets information about a server response.</summary>
    /// <param name="mockId">The mock's ID.</param>
    /// <param name="serverResponseId">The server response's ID.</param>
    public async Task<object> GetMockServerResponseAsync(
        string mockId,
        string serverResponseId,
        CancellationToken cancellationToken = default
    )
    {
        ArgumentNullException.ThrowIfNull(mockId, nameof(mockId));
        ArgumentNullException.ThrowIfNull(serverResponseId, nameof(serverResponseId));

        var request = new RequestBuilder(
            HttpMethod.Get,
            "mocks/{mockId}/server-responses/{serverResponseId}"
        )
            .SetPathParameter("mockId", mockId)
            .SetPathParameter("serverResponseId", serverResponseId)
            .Build();

        var response = await _httpClient
            .SendAsync(request, cancellationToken)
            .ConfigureAwait(false);
        response.EnsureSuccessStatusCode();

        return await response
                .Content.ReadFromJsonAsync<object>(_jsonSerializerOptions, cancellationToken)
                .ConfigureAwait(false) ?? throw new Exception("Failed to deserialize response.");
    }

    /// <summary>Updates a server response.</summary>
    /// <param name="mockId">The mock's ID.</param>
    /// <param name="serverResponseId">The server response's ID.</param>
    public async Task<object> UpdateMockServerResponseAsync(
        UpdateMockServerResponse input,
        string mockId,
        string serverResponseId,
        CancellationToken cancellationToken = default
    )
    {
        ArgumentNullException.ThrowIfNull(input, nameof(input));
        ArgumentNullException.ThrowIfNull(mockId, nameof(mockId));
        ArgumentNullException.ThrowIfNull(serverResponseId, nameof(serverResponseId));

        var request = new RequestBuilder(
            HttpMethod.Put,
            "mocks/{mockId}/server-responses/{serverResponseId}"
        )
            .SetPathParameter("mockId", mockId)
            .SetPathParameter("serverResponseId", serverResponseId)
            .SetContentAsJson(input, _jsonSerializerOptions)
            .Build();

        var response = await _httpClient
            .SendAsync(request, cancellationToken)
            .ConfigureAwait(false);
        response.EnsureSuccessStatusCode();

        return await response
                .Content.ReadFromJsonAsync<object>(_jsonSerializerOptions, cancellationToken)
                .ConfigureAwait(false) ?? throw new Exception("Failed to deserialize response.");
    }

    /// <summary>Deletes a mock server's server response.</summary>
    /// <param name="mockId">The mock's ID.</param>
    /// <param name="serverResponseId">The server response's ID.</param>
    public async Task<DeleteMockServerResponse> DeleteMockServerResponseAsync(
        string mockId,
        string serverResponseId,
        CancellationToken cancellationToken = default
    )
    {
        ArgumentNullException.ThrowIfNull(mockId, nameof(mockId));
        ArgumentNullException.ThrowIfNull(serverResponseId, nameof(serverResponseId));

        var request = new RequestBuilder(
            HttpMethod.Delete,
            "mocks/{mockId}/server-responses/{serverResponseId}"
        )
            .SetPathParameter("mockId", mockId)
            .SetPathParameter("serverResponseId", serverResponseId)
            .Build();

        var response = await _httpClient
            .SendAsync(request, cancellationToken)
            .ConfigureAwait(false);
        response.EnsureSuccessStatusCode();

        return await response
                .Content.ReadFromJsonAsync<DeleteMockServerResponse>(
                    _jsonSerializerOptions,
                    cancellationToken
                )
                .ConfigureAwait(false) ?? throw new Exception("Failed to deserialize response.");
    }
}
